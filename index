<!DOCTYPE html>
<html lang="pt-BR">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Deduplicador CSV/XLSX ‚Äî Confer√™ncia & A√ß√£o Direta</title>
  <!-- Tailwind CSS -->
  <script src="https://cdn.tailwindcss.com"></script>
  <!-- PapaParse (CSV) -->
  <script src="https://cdn.jsdelivr.net/npm/papaparse@5.4.1/papaparse.min.js"></script>
  <!-- SheetJS (XLSX) -->
  <script src="https://cdn.jsdelivr.net/npm/xlsx@0.18.5/dist/xlsx.full.min.js"></script>
  <style>
    :root{--ok:#16a34a;--warn:#f59e0b;--err:#dc2626;--muted:#64748b}
    .mono{font-variant-numeric:tabular-nums}
    .chip{display:inline-flex;gap:.4rem;align-items:center;padding:.2rem .5rem;border-radius:999px;background:#f1f5f9;font-size:.75rem}
    .card{background:#fff;border:1px solid #e2e8f0;border-radius:1rem;box-shadow:0 1px 2px rgba(0,0,0,.04)}
    .tableFix{ max-height:70vh; overflow:auto }
    .badge{font-size:.7rem;padding:.1rem .4rem;border-radius:.5rem;background:#eef2ff}
    .muted{ color:#64748b }
    table thead th{ position:sticky; top:0; background:#fff; box-shadow:inset 0 -1px 0 #e2e8f0; }
    tbody tr:nth-child(even){ background:#f8fafc }
    td,th{ white-space:nowrap }
    .actCell label{ margin-right:.5rem }
    .note{ font-size:.75rem }
    .danger{ color:#b91c1c }
  </style>
</head>
<body class="bg-slate-50 text-slate-900">
  <header class="bg-white border-b sticky top-0 z-10">
    <div class="w-full p-4 flex flex-wrap gap-3 items-center justify-between">
      <h1 class="text-xl md:text-2xl font-semibold">üîé Deduplicador CSV/XLSX ‚Äî Confer√™ncia & A√ß√£o Direta</h1>
      <div class="text-sm text-slate-600">Offline ‚Ä¢ Processa no navegador ‚Ä¢ CSV e XLSX</div>
    </div>
  </header>

  <main class="w-full max-w-none p-4 md:p-6 space-y-6">
    <!-- Upload + Analisador lateral -->
    <section class="card p-4 md:p-6 space-y-4">
      <div class="flex flex-col lg:flex-row gap-6 lg:items-start lg:justify-between">
        <div class="flex-1 min-w-0 space-y-4">
          <div class="flex flex-col md:flex-row gap-4 md:items-center md:justify-between">
            <div>
              <h2 class="text-lg font-semibold">1) Carregue seu arquivo</h2>
              <p class="text-slate-600 text-sm">Aceita <b>CSV</b> e <b>XLSX</b>. Leitura em <em>stream</em> (CSV) e via <span class="badge">SheetJS</span> (XLSX).</p>
            </div>
            <div class="flex gap-2">
              <input id="file" type="file" accept=".csv,text/csv,application/vnd.openxmlformats-officedocument.spreadsheetml.sheet,application/vnd.ms-excel,.xlsx,.xls" class="block text-sm" />
              <button id="btnSample" class="px-3 py-2 rounded bg-slate-900 text-white text-sm">Testar com exemplo</button>
            </div>
          </div>

          <div id="fileMeta" class="text-sm text-slate-700 hidden"></div>

          <div id="mapBox" class="hidden grid md:grid-cols-2 gap-4">
            <div class="space-y-2">
              <h3 class="font-medium">Mapeie as colunas</h3>
              <div class="grid grid-cols-1 sm:grid-cols-2 gap-2">
                <div>
                  <label class="text-sm text-slate-600">Nome</label>
                  <select id="colNome" class="w-full border rounded p-2 text-sm"></select>
                </div>
                <div>
                  <label class="text-sm text-slate-600">Nome da m√£e (opcional)</label>
                  <select id="colMae" class="w-full border rounded p-2 text-sm"></select>
                </div>
                <div>
                  <label class="text-sm text-slate-600">Data de nascimento</label>
                  <select id="colNasc" class="w-full border rounded p-2 text-sm"></select>
                </div>
                <div>
                  <label class="text-sm text-slate-600">CPF (opcional)</label>
                  <select id="colCPF" class="w-full border rounded p-2 text-sm"></select>
                </div>
                <div>
                  <label class="text-sm text-slate-600">CNS/Cart√£o SUS (opcional)</label>
                  <select id="colCNS" class="w-full border rounded p-2 text-sm"></select>
                </div>
                <div>
                  <label class="text-sm text-slate-600">Munic√≠pio (opcional)</label>
                  <select id="colMun" class="w-full border rounded p-2 text-sm"></select>
                </div>
              </div>
            </div>
            <div class="space-y-2">
              <h3 class="font-medium">Regras e sensibilidade</h3>
              <div class="grid grid-cols-1 sm:grid-cols-2 gap-2">
                <label class="flex items-center gap-2 text-sm"><input id="useCPF" type="checkbox" checked> Usar CPF (exato)</label>
                <label class="flex items-center gap-2 text-sm"><input id="useCNS" type="checkbox" checked> Usar CNS (exato)</label>
                <label class="flex items-center gap-2 text-sm"><input id="useMae" type="checkbox" checked> Considerar Nome da m√£e</label>
                <label class="flex items-center gap-2 text-sm"><input id="useMun" type="checkbox"> Considerar Munic√≠pio</label>
                <div class="col-span-2">
                  <label class="text-sm">Similaridade m√≠nima (0.70‚Äì0.98) <span id="thrVal" class="chip">0.90</span></label>
                  <input id="threshold" type="range" min="0.7" max="0.98" step="0.01" value="0.90" class="w-full">
                </div>
                <div class="col-span-2">
                  <label class="text-sm">Bloqueio (acelera√ß√£o)</label>
                  <select id="blocking" class="w-full border rounded p-2 text-sm">
                    <option value="initialYear">Inicial do nome + ano de nascimento (recomendado)</option>
                    <option value="soundexYear">SoundexBR + ano de nascimento</option>
                    <option value="none">Sem bloqueio (mais lento)</option>
                  </select>
                </div>
                <div class="col-span-2">
                  <label class="text-sm flex items-center gap-2"><input id="hardRemove" type="checkbox"> <span>Quando eu clicar <b>Excluir agora</b>, <span class="danger">remover da visualiza√ß√£o</span> imediatamente</span></label>
                  <div class="text-xs muted">Se desligado, o sistema apenas marca para exclus√£o na exporta√ß√£o. Ligado = some da tabela e do grupo.</div>
                </div>
              </div>
            </div>
          </div>

          <div id="startBox" class="hidden flex flex-wrap gap-2 items-center">
            <button id="btnScan" class="px-4 py-2 rounded bg-emerald-600 text-white disabled:opacity-50">2) Encontrar duplicidades</button>
            <button id="btnClear" class="px-3 py-2 rounded border">Limpar</button>
            <div id="progress" class="text-sm text-slate-600"></div>
          </div>
        </div>

        <!-- Analisador ao lado -->
        <aside id="analyzerPanel" class="w-full lg:w-96 shrink-0 card p-4 space-y-3 h-full">
          <h3 class="text-lg font-semibold">Analisador</h3>
          <div id="stats" class="grid grid-cols-2 gap-2 text-sm"></div>
          <div class="space-y-2 text-sm text-slate-700">
            <p class="chip">Regra autom√°tica: manter a <strong>data de nascimento mais antiga</strong>.</p>
            <p class="chip">Voc√™ pode marcar <strong>Excluir agora</strong> por linha ou usar os r√°dios Manter/Excluir.</p>
            <details class="mt-2">
              <summary class="cursor-pointer font-medium">Como a similaridade √© calculada?</summary>
              <ul class="list-disc ml-5 mt-1 text-slate-600">
                <li>Normaliza√ß√£o (caixa, acentos, pontua√ß√£o, espa√ßos, stopwords)</li>
                <li>Jaro‚ÄëWinkler + b√¥nus por dados iguais (data, m√£e, munic√≠pio) e penalidade se datas divergirem.</li>
                <li>Bloqueio por chave para acelerar em bases grandes.</li>
              </ul>
            </details>
          </div>
        </aside>
      </div>
    </section>

    <!-- Resultados -->
    <section id="results" class="hidden">
      <div class="card p-3 md:p-4">
        <div class="flex items-center justify-between mb-3">
          <h2 class="text-lg font-semibold">Grupos suspeitos de duplicidade</h2>
          <div class="flex gap-2 flex-wrap justify-end">
            <button id="btnExportDedup" class="px-3 py-2 rounded bg-indigo-600 text-white text-sm">Exportar Excel (deduplicado & log)</button>
            <button id="btnExportLog" class="px-3 py-2 rounded bg-slate-900 text-white text-sm">Exportar Excel (somente log)</button>
            <button id="btnGenerateVBA" class="px-3 py-2 rounded border border-emerald-500 text-emerald-700 bg-emerald-50 text-sm">Gerar VBA (excluir no Excel)</button>
          </div>
        </div>
        <div class="mb-2 text-xs text-slate-600">Use <b>Excluir agora</b> para aplicar sua decis√£o de forma imediata (visual) ou marque <b>Excluir</b> para apenas registrar para a exporta√ß√£o.</div>
        <div id="groups" class="tableFix text-sm"></div>
      </div>
    </section>
    <section id="vbaBox" class="hidden">
      <div class="card p-3 md:p-4 space-y-3">
        <div class="flex flex-col md:flex-row md:items-start md:justify-between gap-3">
          <div>
            <h3 class="text-lg font-semibold">C√≥digo VBA para exclus√£o autom√°tica no Excel</h3>
            <p id="vbaMeta" class="text-xs muted">Gere o c√≥digo ap√≥s revisar as exclus√µes.</p>
          </div>
          <button id="btnCopyVBA" class="self-start px-3 py-1.5 rounded border text-sm">Copiar c√≥digo</button>
        </div>
        <p class="text-sm text-slate-600">Cole o c√≥digo abaixo em um m√≥dulo VBA (Alt + F11) e ajuste o nome da planilha conforme necess√°rio antes de executar. As linhas consideradas aqui referem-se ao arquivo original (cabe√ßalho na linha 1).</p>
        <textarea id="vbaCode" readonly class="w-full h-48 border rounded p-3 font-mono text-xs"></textarea>
        <div id="vbaCopyStatus" class="text-xs text-emerald-600 hidden">C√≥digo copiado para a √°rea de transfer√™ncia.</div>
      </div>
    </section>
  </main>

  <script>
  // ===== Utilidades BR =====
  const rmAcc = s => String(s||'').normalize('NFD').replace(/\p{Diacritic}/gu,'');
  const norm = s => rmAcc(String(s||'').toUpperCase().replace(/[^A-Z0-9\s]/g,' ').replace(/\s+/g,' ').trim())
                    .replace(/\sD[AEIOU]\s/g,' ').replace(/\sD[AO]S\s/g,' ');
  const onlyDigits = s => String(s||'').replace(/\D/g,'');
  const commonWordCount = (a,b)=>{
    const wa=norm(a).split(' ').filter(Boolean);
    const wb=norm(b).split(' ').filter(Boolean);
    if(!wa.length || !wb.length) return 0;
    const seen=new Set(wb);
    let count=0;
    for(const word of wa){
      if(seen.has(word)){
        count++;
        seen.delete(word);
      }
    }
    return count;
  };
  const parseDateBR = input => {
    if(input instanceof Date && !isNaN(input)) return input;
    if(typeof input==='number' && Number.isFinite(input)){
      const excelEpoch = new Date(Date.UTC(1899, 11, 30));
      const d=new Date(excelEpoch.getTime()+Math.round(input*86400000));
      if(!isNaN(d)) return new Date(d.getUTCFullYear(), d.getUTCMonth(), d.getUTCDate());
    }
    let s=String(input||'').trim(); if(!s) return null;
    const br=s.match(/^(\d{1,2})[\/-](\d{1,2})[\/-](\d{2,4})(?:\D.*)?$/);
    if(br){
      const dd=+br[1], mm=+br[2];
      let yy=+br[3];
      if(br[3].length===2){
        const currentYear=new Date().getFullYear();
        const century=Math.floor(currentYear/100);
        const pivot=currentYear%100;
        const baseCentury=yy>pivot?century-1:century;
        yy=baseCentury*100+yy;
      }
      const d=new Date(yy,mm-1,dd);
      if(d.getFullYear()===yy && d.getMonth()===mm-1 && d.getDate()===dd) return d;
    }
    const iso=s.match(/^(\d{4})-(\d{2})-(\d{2})(?:[ T].*)?$/);
    if(iso){
      const[,yy,mm,dd]=iso.map(Number);
      const d=new Date(yy,mm-1,dd);
      if(d.getFullYear()===yy && d.getMonth()===mm-1 && d.getDate()===dd) return d;
    }
    const t=new Date(s);
    return isNaN(t)?null:t;
  }
  const formatDateBRStr = input => {
    if(input===null || input===undefined) return '';
    const d=parseDateBR(input);
    if(!d) return String(input);
    const day=String(d.getDate()).padStart(2,'0');
    const month=String(d.getMonth()+1).padStart(2,'0');
    const year=String(d.getFullYear()).padStart(4,'0');
    return `${day}/${month}/${year}`;
  };
  const y = d => d? d.getFullYear(): '';
  function soundexBR(str){ str=norm(str).replace(/H/g,''); if(!str) return '';
    const map={B:1,F:1,P:1,V:1,C:2,G:2,J:2,K:2,Q:2,S:2,X:2,Z:2,D:3,T:3,L:4,M:5,N:5,R:6};
    const first=str[0]; let code=first; let prev=map[first]||'';
    for(let i=1;i<str.length;i++){ const ch=str[i]; if(ch===' ') continue; const v=map[ch]||''; if(v!=='' && v!=prev) code+=v; prev=v; }
    return (code+"000").slice(0,4) }
  function jaroWinkler(a,b){ a=norm(a); b=norm(b); if(!a||!b) return 0; const m=Math.floor(Math.max(a.length,b.length)/2)-1;
    let matches=0, trans=0; const am=new Array(a.length).fill(false), bm=new Array(b.length).fill(false);
    for(let i=0;i<a.length;i++){ const s=Math.max(0,i-m), e=Math.min(i+m+1,b.length); for(let j=s;j<e;j++) if(!bm[j]&&a[i]===b[j]){am[i]=bm[j]=true;matches++;break}}
    if(!matches) return 0; let k=0; for(let i=0;i<a.length;i++) if(am[i]){ while(!bm[k]) k++; if(a[i]!==b[k]) trans++; k++; }
    const j=(matches/a.length + matches/b.length + (matches - trans/2)/matches)/3; let l=0; for(; l<Math.min(4,a.length,b.length)&&a[l]===b[l]; l++);
    return j + l*0.1*(1-j) }

  // ===== Estado =====
  let rows=[], headers=[]; let groups=[]; // arrays de √≠ndices
  let keepIdx=new Set(), removedIdx=new Set(), dupTouched=new Set();
  let decisions=new Map(); // rowIndex -> 'keep'|'remove'
  let groupNoDelete=new Set(); // gi -> true
  let hardRemovedRows=new Set(); // linhas originais removidas imediatamente
  let dateHeaderSet=new Set();
  let originalWorkbookData=null;
  let originalSheetName=null;
  let originalSheetRef=null;
  const ui=id=>document.getElementById(id);

  // ===== Entrada (CSV/XLSX) =====
  function loadFromObjects(objs){
    hardRemovedRows.clear();
    rows = objs.map((o,idx)=>({__row:idx+2, ...o}));
    headers = Object.keys(objs[0]||{}).map(h=>norm(h));
    window._headersOriginal = Object.keys(objs[0]||{});
    updateDateHeaderSet();
    ['colNome','colMae','colNasc','colCPF','colCNS','colMun'].forEach(id=>{ const el=ui(id); el.innerHTML=''; window._headersOriginal.forEach((h,i)=>{ const opt=document.createElement('option'); opt.value=i; opt.textContent=h; el.appendChild(opt) }) });
    autoMap(); ui('fileMeta').classList.remove('hidden'); ui('fileMeta').innerHTML = `<span class="chip">Registros: <b>${rows.length}</b></span> <span class="chip">Colunas: <b>${window._headersOriginal.length}</b></span>`; showMap();
  }
  function autoMap(){
    const opts=name=>["NOME","NOME COMPLETO","PACIENTE","ATENDIDO","ALUNO"].some(k=>name.includes(k));
    const om=name=>["MAE","M√ÉE","NOME DA MAE","NOME DA M√ÉE"].some(k=>name.includes(k));
    const ob=name=>["NASC","NASCIMENTO","DATA NASC","DT NASC","DATA DE NASC"].some(k=>name.includes(k));
    const ocpf=name=>["CPF"].some(k=>name.includes(k));
    const ocns=name=>["CNS","CARTAO SUS","CART√ÉO SUS","SUS"].some(k=>name.includes(k));
    const oMun=name=>["MUNIC","MUNICIPIO","MUNIC√çPIO","CIDADE"].some(k=>name.includes(k));
    function fill(sel,pred){
      sel.innerHTML='<option value="">‚Äî</option>'+
        window._headersOriginal.map((h,i)=>`<option value="${i}">${h||headers[i]||''}</option>`).join('');
      const ix=headers.findIndex(h=>pred(h)); if(ix>=0) sel.value=ix;
    }
    fill(ui('colNome'),opts); fill(ui('colMae'),om); fill(ui('colNasc'),ob); fill(ui('colCPF'),ocpf); fill(ui('colCNS'),ocns); fill(ui('colMun'),oMun);
  }
  function showMap(){ ui('mapBox').classList.remove('hidden'); ui('startBox').classList.remove('hidden'); }

  function isLikelyDateHeader(name){
    const normalized=norm(name);
    const hasDatePrefix = normalized.includes('DATA') || normalized.startsWith('DT ') || normalized.startsWith('DT_') || normalized.startsWith('DT');
    if(!hasDatePrefix) return false;
    const keywords=['NASC','NASCIMENTO','ENTRADA','ADMISSAO','EMISSAO','SAIDA','INCLUSAO','CADASTRO'];
    return keywords.some(k=>normalized.includes(k));
  }

  function updateDateHeaderSet(){
    const headersOriginal = Array.isArray(window._headersOriginal)? window._headersOriginal : [];
    dateHeaderSet = new Set(headersOriginal.filter(isLikelyDateHeader));
  }

  function getDateHeadersForCfg(cfg){
    const set=new Set(dateHeaderSet);
    if(cfg?.colNasc!=null){
      const header=window._headersOriginal?.[cfg.colNasc];
      if(header) set.add(header);
    }
    return set;
  }

  ui('file').addEventListener('change', ev=>{
    const f=ev.target.files[0]; if(!f) return;
    rows=[]; headers=[]; groups=[]; keepIdx.clear(); removedIdx.clear(); dupTouched.clear(); decisions.clear(); groupNoDelete.clear(); hardRemovedRows.clear();
    const name=(f.name||'').toLowerCase();
    if(name.endsWith('.xlsx') || name.endsWith('.xls')){
      const fr=new FileReader(); fr.onload=e=>{
        const buffer=e.target.result;
        const data=new Uint8Array(buffer);
        const wb=XLSX.read(data,{type:'array'});
        originalWorkbookData = buffer.slice(0);
        originalSheetName = wb.SheetNames[0] || null;
        const sheet = originalSheetName ? wb.Sheets[originalSheetName] : null;
        originalSheetRef = sheet && sheet['!ref'] ? sheet['!ref'] : null;
        const ws=XLSX.utils.sheet_to_json(sheet||{}, {defval:'', raw:false});
        loadFromObjects(ws);
      }; fr.readAsArrayBuffer(f);
    }else{
      originalWorkbookData=null; originalSheetName=null; originalSheetRef=null;
      Papa.parse(f,{header:true, skipEmptyLines:true, worker:true, encoding:'utf-8', chunk:res=>rows.push(...res.data), complete:()=>loadFromObjects(rows)});
    }
  });

  // Exemplo
  ui('btnSample').addEventListener('click', ()=>{
    originalWorkbookData=null; originalSheetName=null; originalSheetRef=null;
    const csv = `nome,data_nasc,cpf,mae,municipio\n`+
      `JOSE ANTONIO SILVA,12/03/1980,12345678909,MARIA DE LOURDES,CAFRNAUM\n`+
      `JOS√â A SILVA,1980-03-12,123.456.789-09,MARIA LOURDES,CAFARNAUM\n`+
      `ANA BEATRIZ SOUZA,05/11/1992,,JOANA D ARC,SOBRADINHO\n`+
      `ANA B SOUZA,05/11/1992,,JOANA D'ARC,SOBRADINHO\n`+
      `CARLA NUNES,2001-01-01,11122233344,,SALVADOR`;
    Papa.parse(csv,{header:true, complete: r=> loadFromObjects(r.data)});
  });

  ui('threshold').addEventListener('input', e=> ui('thrVal').textContent=(+e.target.value).toFixed(2));

  // ===== Similaridade / Cluster =====
  function get(r,idx){ if(idx===''||idx==null) return ''; const key=window._headersOriginal[idx]; return r[key]; }
  function blockKey(r,cfg){ const nome=get(r,cfg.colNome); const dn=parseDateBR(get(r,cfg.colNasc)); const ano=y(dn)||''; if(cfg.blocking==='initialYear') return (norm(nome)[0]||'')+'|'+ano; if(cfg.blocking==='soundexYear') return soundexBR(nome)+'|'+ano; return 'ALL'; }
  function score(a,b){ return jaroWinkler(a,b) }
  function compare(r1,r2,cfg){
    const cpf1=onlyDigits(get(r1,cfg.colCPF)), cpf2=onlyDigits(get(r2,cfg.colCPF));
    const cns1=onlyDigits(get(r1,cfg.colCNS)), cns2=onlyDigits(get(r2,cfg.colCNS));
    if(cfg.useCPF && cpf1 && cpf2 && cpf1===cpf2) return {match:true,reason:'CPF igual',sim:1};
    if(cfg.useCNS && cns1 && cns2 && cns1===cns2) return {match:true,reason:'CNS igual',sim:1};
    const nome1=get(r1,cfg.colNome), nome2=get(r2,cfg.colNome);
    const nasc1=parseDateBR(get(r1,cfg.colNasc)), nasc2=parseDateBR(get(r2,cfg.colNasc));
    const commonWords=commonWordCount(nome1,nome2);
    const sameBirth=nasc1 && nasc2 && nasc1.getTime()===nasc2.getTime();
    let penalty=0; const penaltyInfo=[];
    if(nasc1 && nasc2){
      const sameDay=nasc1.getTime()===nasc2.getTime();
      if(!sameDay){
        const year1=y(nasc1), year2=y(nasc2);
        if(year1 && year2 && year1!==year2) return {match:false, reason:`Anos de nascimento diferentes (${year1} √ó ${year2})`, sim:0};
        penalty+=0.18;
        penaltyInfo.push(`datas diferentes (${formatDateBRStr(nasc1)} √ó ${formatDateBRStr(nasc2)})`);
      }
    }
    const sNome=score(nome1,nome2); let bonus=0; const bonusInfo=[];
    if(nasc1&&nasc2&&nasc1.getTime()===nasc2.getTime()){ bonus+=0.08; bonusInfo.push('data igual'); }
    if(cfg.useMae){
      const mae1=get(r1,cfg.colMae), mae2=get(r2,cfg.colMae);
      const sm=mae1||mae2?score(mae1,mae2):0;
      if(sm>0){ const inc=Math.min(0.08, sm*0.08); if(inc>0){ bonus+=inc; bonusInfo.push(`m√£e ${sm.toFixed(2)}`); } }
    }
    if(cfg.useMun){
      const m1=get(r1,cfg.colMun), m2=get(r2,cfg.colMun);
      if(m1&&m2&&norm(m1)===norm(m2)){ bonus+=0.02; bonusInfo.push('munic√≠pio igual'); }
    }
    const rawSim = sNome + bonus - penalty;
    const sim = Math.min(1, Math.max(0, rawSim));
    if(!(commonWords>=3 && sameBirth)){
      const parts=[];
      if(commonWords<3) parts.push(`menos de 3 palavras coincidentes no nome (${commonWords})`);
      if(!sameBirth) parts.push('data de nascimento ausente ou diferente');
      const reasonDetail = parts.length? parts.join(' e '):'regra n√£o atendida';
      return {match:false, reason:`Regra de duplicidade: ${reasonDetail}`, sim};
    }
    const details = `nome:${sNome.toFixed(2)}${bonusInfo.length?` + ${bonusInfo.join(' + ')}`:''}${penaltyInfo.length?` - ${penaltyInfo.join(' - ')}`:''}`;
    return {match: sim>=cfg.threshold, reason:`sim=${sim.toFixed(2)} (${details})`, sim};
  }
  function clusterize(rows,cfg){ const blocks=new Map(); rows.forEach((r,i)=>{ const k=blockKey(r,cfg); if(!blocks.has(k)) blocks.set(k,[]); blocks.get(k).push(i)});
    const visited=new Set(); const clusters=[]; for(const ids of blocks.values()){
      for(const i of ids){ if(visited.has(i)) continue; visited.add(i); const q=[i]; const cur=[i];
        while(q.length){ const a=q.shift(); for(const j of ids){ if(visited.has(j)||j===a) continue; const cmp=compare(rows[a],rows[j],cfg); if(cmp.match){ visited.add(j); q.push(j); cur.push(j) }} }
        if(cur.length>1) clusters.push(cur);
      }
    } return clusters }

  // ===== L√≥gica principal =====
  function buildCfg(){ return {
    colNome: ui('colNome').value!==''? +ui('colNome').value : null,
    colMae: ui('colMae').value!==''? +ui('colMae').value : null,
    colNasc: ui('colNasc').value!==''? +ui('colNasc').value : null,
    colCPF: ui('colCPF').value!==''? +ui('colCPF').value : null,
    colCNS: ui('colCNS').value!==''? +ui('colCNS').value : null,
    colMun: ui('colMun').value!==''? +ui('colMun').value : null,
    threshold:+ui('threshold').value, useCPF:ui('useCPF').checked, useCNS:ui('useCNS').checked, useMae:ui('useMae').checked, useMun:ui('useMun').checked,
    blocking: ui('blocking').value, hardRemove: ui('hardRemove').checked } }

  function countFilledCells(row){
    const headers = Array.isArray(window._headersOriginal) ? window._headersOriginal : [];
    let filled = 0;
    headers.forEach(h=>{
      const value = row?.[h];
      if(value===null || value===undefined) return;
      if(typeof value === 'string'){ if(value.trim()!=='') filled++; return; }
      if(typeof value === 'number'){ if(!Number.isNaN(value)) filled++; return; }
      if(value instanceof Date){ if(!Number.isNaN(value.getTime())) filled++; return; }
      if(typeof value === 'boolean'){ filled++; return; }
      if(Array.isArray(value)){ if(value.length>0) filled++; return; }
      const text = String(value).trim();
      if(text!=='') filled++;
    });
    return filled;
  }

  function pickKeepIndex(indices,cfg){
    let best=indices[0];
    let bestFilled=countFilledCells(rows[best]);
    const sentinel=new Date(8640000000000000);
    let bestDate=parseDateBR(get(rows[best],cfg.colNasc))||sentinel;
    for(const i of indices){
      const filled=countFilledCells(rows[i]);
      const d=parseDateBR(get(rows[i],cfg.colNasc))||sentinel;
      if(filled>bestFilled || (filled===bestFilled && d<bestDate)){
        best=i;
        bestFilled=filled;
        bestDate=d;
      }
    }
    return best;
  }

  function renderStats(){ const total=rows.length; const affected=dupTouched.size; const totalRemoved=removedIdx.size + hardRemovedRows.size; ui('stats').innerHTML=`
    <div class="p-2 rounded bg-emerald-50 border text-emerald-800">Total linhas<br><b class="mono text-lg">${total}</b></div>
    <div class="p-2 rounded bg-indigo-50 border text-indigo-800">Grupos<br><b class="mono text-lg">${groups.length}</b></div>
    <div class="p-2 rounded bg-amber-50 border text-amber-800">Registros tocados<br><b class="mono text-lg">${affected}</b></div>
    <div class="p-2 rounded bg-rose-50 border text-rose-800">Exclu√≠dos (proposta)<br><b class="mono text-lg">${totalRemoved}</b></div>` }

  function renderGroups(){
    const container=ui('groups'); if(groups.length===0){ container.innerHTML='<div class="text-slate-600">Nenhum grupo suspeito encontrado com as regras atuais.</div>'; return }
    const cfg=buildCfg();
    const cols = window._headersOriginal; container.innerHTML='';
    const dateHeaders = getDateHeadersForCfg(cfg);
    groups.forEach((g,gi)=>{
      const rowsHtml = g.map(idx=>{
        const r=rows[idx]; const act = decisions.get(idx) || (removedIdx.has(idx)?'remove':'keep');
        const actionHtml = `<td class="px-2 py-1 border-t actCell"><label><input type="radio" name="g${gi}-r${idx}" value="keep" ${act==='keep'?'checked':''}> Manter</label><label><input type="radio" name="g${gi}-r${idx}" value="remove" ${act==='remove'?'checked':''}> Excluir</label></td>`;
        const cmdHtml = `<td class="px-2 py-1 border-t whitespace-nowrap">
            <button data-del="${idx}" data-gi="${gi}" class="px-2 py-0.5 text-xs rounded border border-rose-300 hover:bg-rose-50">üóë Excluir agora</button>
            <button data-keep="${idx}" class="ml-1 px-2 py-0.5 text-xs rounded border border-emerald-300 hover:bg-emerald-50">‚úì Manter</button>
          </td>`;
        const cells = cols.map(h=>{
          let value=r[h]??'';
          if(dateHeaders.has(h)) value=formatDateBRStr(value) || '';
          return `<td class=\"px-2 py-1 border-t\">${value}</td>`;
        }).join('');
        return `<tr data-idx=\"${idx}\" data-gi=\"${gi}\" class=\"hover:bg-indigo-50\">${actionHtml}<td class=\"px-2 py-1 border-t font-medium\">${r.__row??''}</td>${cmdHtml}${cells}</tr>`
      }).join('');
      const head = ['A√ß√£o','# Linha','Comandos',...cols].map(h=>`<th class="px-2 py-1 text-left text-slate-600">${h}</th>`).join('');
      const giTitle = `<div class=\"flex flex-wrap items-center justify-between gap-2\"><div class=\"font-medium\">Grupo #${gi+1} <span class=\"badge\">${g.length} registros</span></div><label class=\"text-sm flex items-center gap-2\"><input type=\"checkbox\" data-g-none=\"${gi}\" ${groupNoDelete.has(gi)?'checked':''}> N√£o excluir nenhum deste grupo</label></div><div class=\"note muted\">Regra autom√°tica sugerida: manter a data de nascimento mais antiga. Voc√™ pode sobrescrever abaixo.</div>`;
      const table = `<table class="w-full text-xs"><thead><tr>${head}</tr></thead><tbody>${rowsHtml}</tbody></table>`;
      const box=document.createElement('div'); box.className='border rounded-lg p-2 mb-3 bg-white'; box.innerHTML=giTitle+`<div class="mt-2">${table}</div>`; container.appendChild(box);
    });

    // listeners
    container.querySelectorAll('input[type="radio"]').forEach(inp=>{
      inp.addEventListener('change', e=>{ const tr=e.target.closest('tr'); const idx=+tr.getAttribute('data-idx'); decisions.set(idx, e.target.value); applyDecisions(buildCfg()) })
    });
    container.querySelectorAll('button[data-keep]').forEach(btn=> btn.addEventListener('click', ()=>{ const idx=+btn.getAttribute('data-keep'); decisions.set(idx,'keep'); applyDecisions(buildCfg()); renderGroups(); }));
    container.querySelectorAll('button[data-del]').forEach(btn=> btn.addEventListener('click', ()=>{ const idx=+btn.getAttribute('data-del'); const gi=+btn.getAttribute('data-gi'); handleImmediateDelete(idx,gi); }));
    container.querySelectorAll('input[type="checkbox"][data-g-none]').forEach(chk=> chk.addEventListener('change', e=>{ const gi=+e.target.getAttribute('data-g-none'); if(e.target.checked) groupNoDelete.add(gi); else groupNoDelete.delete(gi); applyDecisions(buildCfg()); renderGroups(); }));
  }

  function computeAuto(cfg){ removedIdx.clear(); keepIdx.clear(); dupTouched.clear(); groups.forEach(g=> g.forEach(i=>dupTouched.add(i)) ); groups.forEach(g=>{ const keep=pickKeepIndex(g,cfg); keepIdx.add(keep); g.forEach(i=>{ if(i!==keep) removedIdx.add(i) }) }); }

  function applyDecisions(cfg){ removedIdx.clear(); keepIdx.clear(); groups.forEach((g,gi)=>{ if(groupNoDelete.has(gi)){ g.forEach(i=>keepIdx.add(i)); return } const markedKeep=[], markedRemove=[]; g.forEach(i=>{ const d=decisions.get(i); if(d==='keep') markedKeep.push(i); if(d==='remove') markedRemove.push(i) }); if(markedKeep.length===0 && markedRemove.length===0){ const keep=pickKeepIndex(g,cfg); keepIdx.add(keep); g.forEach(i=>{ if(i!==keep) removedIdx.add(i) }); return } markedKeep.forEach(i=>keepIdx.add(i)); g.forEach(i=>{ if(keepIdx.has(i)) return; if(markedRemove.includes(i)) { removedIdx.add(i); return; } if(markedRemove.length>0) { /* mant√©m n√£o marcados */ } else { const keep=pickKeepIndex(g,cfg); if(i!==keep) removedIdx.add(i); else keepIdx.add(i); } }); }); renderStats(); }

  // ===== A√ß√£o direta: Excluir agora =====
  function handleImmediateDelete(idx,gi){ const cfg=buildCfg(); decisions.set(idx,'remove'); if(!cfg.hardRemove){ applyDecisions(cfg); renderGroups(); return; }
    // hard remove: tira da base e reagrupa
    const originalRow = rows[idx]?.__row;
    if(originalRow!=null) hardRemovedRows.add(originalRow);
    rows.splice(idx,1);
    // Rebuild estruturas (√≠ndices mudaram)
    decisions = new Map(); removedIdx.clear(); keepIdx.clear(); dupTouched.clear(); groupNoDelete.delete(gi);
    groups = clusterize(rows,cfg);
    renderGroups(); applyDecisions(cfg); renderStats();
  }

  // ===== Bot√µes principais =====
  ui('btnScan').addEventListener('click', ()=>{ const cfg=buildCfg(); if(cfg.colNome==null || cfg.colNasc==null){ alert('Mapeie ao menos Nome e Data de Nascimento.'); return } const t0=performance.now(); ui('progress').textContent='Processando‚Ä¶'; setTimeout(()=>{ groups = clusterize(rows,cfg); computeAuto(cfg); decisions.clear(); groupNoDelete.clear(); ui('results').classList.remove('hidden'); renderGroups(); applyDecisions(cfg); ui('progress').textContent=`OK em ${(performance.now()-t0).toFixed(0)} ms. Grupos: ${groups.length}.`; }, 10); });
  ui('btnClear').addEventListener('click', ()=> location.reload());

  // ===== Exporta√ß√£o =====
  function toWorksheet(arr){ return XLSX.utils.json_to_sheet(arr, {header: window._headersOriginal}); }

  function cloneOriginalWorkbook(){
    if(!originalWorkbookData) return null;
    try{
      if(originalWorkbookData instanceof ArrayBuffer){
        return XLSX.read(originalWorkbookData.slice(0), {type:'array'});
      }
      if(ArrayBuffer.isView(originalWorkbookData)){
        return XLSX.read(originalWorkbookData.slice(0), {type:'array'});
      }
      return XLSX.read(originalWorkbookData, {type:'array'});
    }catch(err){
      console.error('Falha ao clonar workbook original', err);
      return null;
    }
  }

  function prepareCellValue(value, templateCell){
    const templateType = templateCell?.t;
    if(value===null || value===undefined || value===''){
      return {empty:true, type: templateType};
    }
    if(templateType==='n' && typeof value==='number'){
      return {value, type:'n'};
    }
    if(templateType==='d'){
      if(value instanceof Date) return {value, type:'d'};
      const parsed=parseDateBR(value);
      if(parsed) return {value:parsed, type:'d'};
    }
    if(value instanceof Date) return {value, type:'d'};
    return {value:String(value), type:'s'};
  }

  function removeSheetIfExists(wb,name){
    if(!wb || !name) return;
    const idx=wb.SheetNames.indexOf(name);
    if(idx>=0){
      wb.SheetNames.splice(idx,1);
      delete wb.Sheets[name];
    }
  }

  function applyDataToTemplateSheet(sheet, headers, dataRows){
    if(!sheet || !Array.isArray(headers) || headers.length===0) return;
    const ref = originalSheetRef || sheet['!ref'] || 'A1';
    let range;
    try{ range=XLSX.utils.decode_range(ref); }
    catch(err){ range={s:{r:0,c:0}, e:{r:dataRows.length?dataRows.length:0, c:headers.length?headers.length-1:0}}; }
    const startRow = range.s.r + 1;
    const colOffset = range.s.c;
    const templates=headers.map((_,ci)=>{
      const cellRef=XLSX.utils.encode_cell({r:startRow, c:colOffset+ci});
      const cell=sheet[cellRef];
      return cell?{...cell}:null;
    });
    for(let ri=0; ri<dataRows.length; ri++){
      const rowData=dataRows[ri]||{};
      for(let ci=0; ci<headers.length; ci++){
        const key=headers[ci];
        const value=rowData[key];
        const addr={r:startRow+ri, c:colOffset+ci};
        const cellRef=XLSX.utils.encode_cell(addr);
        const templateCell=templates[ci];
        let cell=sheet[cellRef];
        if(!cell){
          cell=templateCell?{...templateCell}:{t:'s'};
        }
        const prepared=prepareCellValue(value, templateCell);
        if(prepared.empty){
          if(templateCell && 'v' in templateCell){
            if(templateCell.t==='n' || templateCell.t==='d') delete cell.v;
            else cell.v='';
          }else{
            cell.v='';
          }
          if(prepared.type) cell.t=prepared.type;
          else if(templateCell?.t) cell.t=templateCell.t;
          else delete cell.t;
        }else{
          cell.v=prepared.value;
          if(prepared.type) cell.t=prepared.type;
          else if(templateCell?.t) cell.t=templateCell.t;
          else if(typeof prepared.value==='number') cell.t='n';
          else cell.t='s';
          if(prepared.type==='d' && templateCell?.z) cell.z=templateCell.z;
        }
        delete cell.f;
        delete cell.w;
        sheet[cellRef]=cell;
      }
    }
    const originalLastRow=range.e.r;
    for(let r=startRow + dataRows.length; r<=originalLastRow; r++){
      for(let ci=0; ci<headers.length; ci++){
        const addr={r, c:colOffset+ci};
        const cellRef=XLSX.utils.encode_cell(addr);
        const templateCell=templates[ci];
        const cell=sheet[cellRef];
        if(cell){
          const prepared=prepareCellValue('', templateCell);
          if(templateCell && 'v' in templateCell){
            if(templateCell.t==='n' || templateCell.t==='d') delete cell.v;
            else cell.v='';
          }else{
            cell.v='';
          }
          if(prepared.type) cell.t=prepared.type;
          else if(templateCell?.t) cell.t=templateCell.t;
          else delete cell.t;
          delete cell.f;
          delete cell.w;
          sheet[cellRef]=cell;
        }
      }
    }
    const lastRow=Math.max(range.s.r, startRow + dataRows.length - 1, range.e.r);
    const lastCol=Math.max(range.e.c, colOffset + headers.length - 1);
    sheet['!ref']=XLSX.utils.encode_range({s:{r:range.s.r, c:range.s.c}, e:{r:lastRow, c:lastCol}});
  }

  function buildWorkbookWithTemplate(dedupRows, logRows){
    if(!originalWorkbookData || !originalSheetName) return null;
    const headers=Array.isArray(window._headersOriginal)?window._headersOriginal:[];
    if(headers.length===0) return null;
    const wb=cloneOriginalWorkbook();
    if(!wb) return null;
    const sheet=wb.Sheets[originalSheetName];
    if(sheet){
      applyDataToTemplateSheet(sheet, headers, dedupRows);
      const finalName='Final_sem_duplicidade';
      if(originalSheetName!==finalName){
        removeSheetIfExists(wb, finalName);
        wb.Sheets[finalName]=sheet;
        const idx=wb.SheetNames.indexOf(originalSheetName);
        if(idx>=0) wb.SheetNames[idx]=finalName;
        delete wb.Sheets[originalSheetName];
      }
    }
    removeSheetIfExists(wb, 'Log_deduplicacao');
    const logSheet=XLSX.utils.json_to_sheet(logRows);
    XLSX.utils.book_append_sheet(wb, logSheet, 'Log_deduplicacao');
    return wb;
  }

  function formatRowForExport(row,dateHeaders){
    const base={...row};
    if(!(dateHeaders instanceof Set) || dateHeaders.size===0) return base;
    dateHeaders.forEach(key=>{
      if(!(key in base)) return;
      const original=base[key];
      if(original===null || original===undefined || original===''){ base[key]=''; return; }
      const parsed=parseDateBR(original);
      base[key]=parsed?formatDateBRStr(parsed):String(original);
    });
    return base;
  }

  function exportExcel(){ const cfg=buildCfg(); applyDecisions(cfg); const dateHeaders=getDateHeadersForCfg(cfg);
    const dedup = rows.map((row,i)=>({row,i})).filter(({i})=>!removedIdx.has(i)).map(({row})=>formatRowForExport(row,dateHeaders));
    const logRows=[]; groups.forEach((g,gi)=>{ const autoKeep=pickKeepIndex(g,cfg); g.forEach(i=>{ const decided=decisions.get(i); const status = removedIdx.has(i)?'EXCLU√çDO':'MANTIDO'; let motivo=''; if(groupNoDelete.has(gi)) motivo='Mantido por decis√£o manual (grupo marcado como n√£o excluir)'; else if(decided==='keep') motivo='Mantido por decis√£o manual'; else if(decided==='remove') motivo='Exclu√≠do por decis√£o manual'; else motivo = (i===autoKeep)?'Mantido (regra: data mais antiga)':'Exclu√≠do (duplicidade pelo algoritmo)'; const base=formatRowForExport(rows[i],dateHeaders); logRows.push({Log: status+' ‚Äî '+motivo, Grupo: gi+1, LinhaOriginal: rows[i]?.__row ?? '', ...base}); }) });
    let wb=buildWorkbookWithTemplate(dedup, logRows);
    if(!wb){
      wb=XLSX.utils.book_new();
      const ws1=toWorksheet(dedup);
      const ws2=XLSX.utils.json_to_sheet(logRows);
      XLSX.utils.book_append_sheet(wb, ws1, 'Final_sem_duplicidade');
      XLSX.utils.book_append_sheet(wb, ws2, 'Log_deduplicacao');
    }
    XLSX.writeFile(wb, 'resultado_deduplicacao.xlsx'); }

  function exportLogOnly(){ const cfg=buildCfg(); applyDecisions(cfg); const dateHeaders=getDateHeadersForCfg(cfg); const logRows=[]; groups.forEach((g,gi)=>{ const autoKeep=pickKeepIndex(g,cfg); g.forEach(i=>{ const decided=decisions.get(i); const status = removedIdx.has(i)?'EXCLU√çDO':'MANTIDO'; let motivo=''; if(groupNoDelete.has(gi)) motivo='Mantido por decis√£o manual (grupo marcado como n√£o excluir)'; else if(decided==='keep') motivo='Mantido por decis√£o manual'; else if(decided==='remove') motivo='Exclu√≠do por decis√£o manual'; else motivo=(i===autoKeep)?'Mantido (regra: data mais antiga)':'Exclu√≠do (duplicidade pelo algoritmo)'; const base=formatRowForExport(rows[i],dateHeaders); logRows.push({Log: status+' ‚Äî '+motivo, Grupo: gi+1, LinhaOriginal: rows[i]?.__row ?? '', ...base}); }) }); const wb=XLSX.utils.book_new(); const ws=XLSX.utils.json_to_sheet(logRows); XLSX.utils.book_append_sheet(wb, ws, 'Log_deduplicacao'); XLSX.writeFile(wb, 'log_deduplicacao.xlsx'); }

  ui('btnExportDedup').addEventListener('click', exportExcel);
  ui('btnExportLog').addEventListener('click', exportLogOnly);

  function collectRemovedRows(cfg){
    applyDecisions(cfg);
    const nums=new Set(hardRemovedRows);
    removedIdx.forEach(i=>{
      const r=rows[i];
      const original=r?.__row;
      if(original!=null) nums.add(original);
    });
    return Array.from(nums).filter(n=>Number.isFinite(n)).sort((a,b)=>a-b);
  }

  function formatVbaArray(nums){
    if(!nums.length) return 'Array()';
    const chunkSize=25;
    const lines=[];
    for(let i=0;i<nums.length;i+=chunkSize) lines.push(nums.slice(i,i+chunkSize).join(', '));
    if(lines.length===1) return `Array(${lines[0]})`;
    return `Array(${lines[0]}, _\n          ${lines.slice(1).join(', _\n          ')})`;
  }

  function buildVbaCode(nums){
    if(!nums.length) return "' Nenhuma linha foi marcada para exclus√£o.";
    const arrExpr=formatVbaArray(nums);
    return [
      "' C√≥digo gerado automaticamente pelo Deduplicador",
      "Sub ExcluirLinhasDuplicadas()",
      "    Dim linhas As Variant",
      "    Dim ws As Worksheet",
      "    Set ws = ThisWorkbook.Worksheets(\"NOME_DA_PLANILHA\") ' ajuste conforme necess√°rio",
      `    linhas = ${arrExpr}`,
      "    Application.ScreenUpdating = False",
      "    Application.Calculation = xlCalculationManual",
      "    On Error GoTo Fim",
      "    Dim i As Long",
      "    For i = UBound(linhas) To LBound(linhas) Step -1",
      "        ws.Rows(linhas(i)).Delete",
      "    Next i",
      "Fim:",
      "    Application.Calculation = xlCalculationAutomatic",
      "    Application.ScreenUpdating = True",
      "End Sub"
    ].join('\n');
  }

  function downloadVbaFile(code){
    const blob=new Blob([code],{type:'text/plain;charset=utf-8'});
    const url=URL.createObjectURL(blob);
    const a=document.createElement('a');
    a.href=url;
    a.download='excluir_linhas_deduplicadas.bas';
    document.body.appendChild(a);
    a.click();
    document.body.removeChild(a);
    setTimeout(()=>URL.revokeObjectURL(url), 1000);
  }

  ui('btnGenerateVBA').addEventListener('click', ()=>{
    const cfg=buildCfg();
    const linhas=collectRemovedRows(cfg);
    const code=buildVbaCode(linhas);
    ui('vbaCode').value=code;
    const meta=linhas.length? `${linhas.length} linha(s) do arquivo original ser√£o exclu√≠das automaticamente.` : 'Nenhuma linha marcada para exclus√£o.';
    ui('vbaMeta').textContent=meta;
    ui('vbaBox').classList.remove('hidden');
    ui('vbaCopyStatus').classList.add('hidden');
    downloadVbaFile(code);
  });

  ui('btnCopyVBA').addEventListener('click', async ()=>{
    const code=ui('vbaCode').value;
    try{
      await navigator.clipboard.writeText(code);
      ui('vbaCopyStatus').textContent='C√≥digo copiado para a √°rea de transfer√™ncia.';
      ui('vbaCopyStatus').classList.remove('hidden');
    }catch(err){
      ui('vbaCopyStatus').textContent='N√£o foi poss√≠vel copiar automaticamente. Copie manualmente o texto acima.';
      ui('vbaCopyStatus').classList.remove('hidden');
    }
  });
  </script>
</body>
</html>
